<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>임종훈의 포트폴리오 - 경력 기술</title>
    <link rel="stylesheet" href="css/style.css">
    <style>.modal-hidden-content { display: none !important; }</style>
</head>
<body class="sub-page">

    <nav class="navbar">
        <ul>
            <li><a href="index.html">내 소개</a></li>
            <li><a href="experience.html" class="active">경력 기술</a></li>
            <li><a href="portfolio.html">포트폴리오</a></li>
            <li><a href="contact.html">Contact</a></li>
        </ul>
    </nav>
    
    <div class="page-container">
        
        <aside class="side-nav">
            <ul>
                <li><a href="#experience-projects" class="active">프로젝트</a></li>
                <li><a href="#experience-details">경력 기술</a></li>
                <li><a href="#version-control">형상 관리</a></li>
            </ul>
        </aside>

        <main class="main-content">
            <div class="page-header"><h1>경력 기술</h1></div>
            
            <section id="experience-projects" class="content-section">
                <h2 class="section-title">프로젝트</h2><p class="section-subtitle">진행했던 프로젝트들을 소개합니다.</p>
                
                <div class="project-item">
                    <div class="project-image"><img src="images/metin.jpg" alt="메틴 파멸의 서곡"></div>
                    <div class="project-description">
                        <h3>메틴: 파멸의 서곡</h3><p class="project-date">2024.05 - 현재</p>
                        <p><strong>C#</strong>, <strong>유니티</strong>로 개발한 <strong>리니지 라이크</strong> 장르의 신규 모바일 프로젝트입니다. 주된 업무로는 <strong>SDK</strong> 및 <strong>최적화</strong>와 <strong>빌드</strong>를 담당했습니다.</p>
                        <p>출시 이후에는 인게임 <strong>콘텐츠 개발</strong> 및 <strong>유지보수</strong> 업무를 담당하고 있습니다.</p>
                        <div class="project-details">
                            <div><h4>SDK</h4><ul><li><strong>Firebase</strong>-Auth/Messaging</li><li><strong>Unity IAP</strong></li><li><strong>Adjust</strong>, <strong>AIHelp</strong></li></ul></div>
                            <div><h4>콘텐츠</h4><ul><li>공성전</li><li>월드 던전, 공성 던전</li><li>랭킹 시스템</li><li>허수아비 수련 시스템</li><li>칭호 시스템</li></ul></div>
                            <div><h4>빌드</h4><ul><li>One, Galaxy, Play Unity 빌드</li><li><strong>IOS XCode</strong> 빌드</li></ul></div>
                            <div><h4>최적화</h4><ul><li><strong>LateBinding</strong>/메모리 중복 제거</li><li><strong>DrawCall</strong> 최적화</li></ul></div>
                        </div>
                    </div>
                </div>

                <div class="project-item reverse">
                    <div class="project-image"><img src="images/cheonsangbi.png" alt="천상비M"></div>
                    <div class="project-description">
                        <h3>천상비M</h3><p class="project-date">2023.09 - 2024.05</p>
                        <p><strong>C#</strong>, <strong>유니티</strong>로 개발한 <strong>리니지라이크</strong> 장르의 모바일 프로젝트입니다. 주된 업무로는 <strong>유지보수</strong> 및 <strong>콘텐츠 개발</strong>, <strong>빌드</strong>를 담당했습니다.</p>
                        <div class="project-details">
                            <div><h4>콘텐츠 개발</h4><ul><li>이벤트 제작</li><li>NPC 우호도/파견</li><li>강화 도감</li><li>사냥/장비 도감 작업</li><li>캐시 일괄 구매</li></ul></div>
                            <div><h4>빌드</h4><ul><li>One, Galaxy, Play Unity 빌드</li><li><strong>IOS XCode</strong> 빌드</li></ul></div>
                            <div><h4>유지보수 작업</h4><ul><li>CS 처리</li><li>해외 서비스를 위한 <strong>Localization</strong></li></ul></div>
                        </div>
                    </div>
                </div>
            </section>

            <section id="experience-details" class="content-section">
                <hr class="section-divider"><h2 class="section-title">경력 기술</h2>
                <div class="task-section">
                    <div class="task-grid">
                        <div class="task-button" data-content-id="optimization-content"><div class="circle"><span>최적화</span></div><div class="task-label"><h4>최적화</h4><p>최적화: 1.77GB → 1.22GB</p></div></div>
                        <div class="task-button" data-content-id="sdk-content"><div class="circle"><span>SDK</span></div><div class="task-label"><h4>SDK</h4><p>Firebase/IAP/Adjust</p></div></div>
                        <div class="task-button" data-content-id="build-content"><div class="circle"><span>Build</span></div><div class="task-label"><h4>빌드</h4><p>AOS/IOS</p></div></div>
                        <div class="task-button" data-content-id="contents-content"><div class="circle"><span>Contents</span></div><div class="task-label"><h4>콘텐츠</h4><p>인게임 시스템 개발</p></div></div>
                    </div>
                </div>
            </section>

            <section id="version-control" class="content-section">
                <hr class="section-divider"><h2 class="section-title">형상 관리</h2>
                <div class="project-item">
                    <div class="project-image"><img src="images/version-control.png" alt="형상 관리"></div>
                    <div class="project-description">
                        <h4><strong>Tortoise SVN</strong></h4>
                        <p>현재 회사 프로젝트의 형상 관리를 <strong>Tortoise SVN</strong>을 통해 수행하고 있습니다. <strong>GitHub</strong>와는 달리 로컬 저장소를 지원하지 않아 중앙 서버 의존성이 있지만, 변경 이력 추적과 기존 코드와의 비교가 간편하다는 장점이 있습니다.</p>
                        <p>형상 관리의 효율성을 높이기 위해, 빌드 과정에서 자동으로 최신 코드로 업데이트할 수 있는 간단한 <strong>배치 파일</strong>을 제작하여 <strong>SVN 업데이트를 자동화</strong>했습니다. 이를 통해 형상 관리의 편의성과 일관성을 높였습니다.</p>
                        <h4 style="margin-top: 30px;"><strong>GitHub</strong></h4>
                        <p>개인 및 팀 프로젝트를 진행할 때 사용하는 형상관리 툴 입니다. 특히 팀 프로젝트 진행 시, <strong>브랜치</strong>를 사용한 작업 분리가 용이해서 기능별 작업 관리와 <strong>병합 기능</strong>이 직관적이고 용이했습니다.</p>
                        <p>또한, 로컬 저장소에 저장 후 커밋 후 원하는 시점에 <strong>Push</strong>할 수 있어, 불필요한 <strong>Conflict를 줄이고</strong> 안정적인 개발 환경을 유지할 수 있었습니다.</p>
                    </div>
                </div>
            </section>
        </main>
    </div>

    <div id="myModal" class="modal-overlay">
        <div class="modal-content"><span class="close-button">&times;</span><div id="modal-dynamic-content"></div></div>
    </div>

    <div id="imageModal" class="image-modal-overlay">
        <span class="close-image-modal">&times;</span>
        <img class="image-modal-content" id="largeImage">
    </div>

    <div class="modal-hidden-content">
    <div id="optimization-content" data-align="left">
    <h2>최적화 상세</h2>
    
    <ul class="modal-tabs">
        <li class="active" data-target="opt-tab-1">LateBinding</li>
        <li data-target="opt-tab-2">SharedMap</li>
        <li data-target="opt-tab-3">Tilemap</li>
        <li data-target="opt-tab-4">AssetBundle</li>
        <li data-target="opt-tab-5">Big Texture</li>
    </ul>

    <div class="modal-tab-container">
            <div id="opt-tab-1" class="modal-tab-content active">
                <h4>1. SpriteAtlas LateBinding</h4>
                <h5>문제점</h5>
                <p><strong>Bundle</strong> 사용 시 이미지를 <strong>SpriteAtlas.asset</strong>을 통해 가져오지 않고, Bundle에 포함된 <strong>SpriteAtlas</strong>를 사용. <strong>SpriteAtlas</strong>가 메모리에 중복 적재되는 문제 발견.</p>
                <p style="padding-left: 1em; text-indent: -1em;">상황 : 게임 실행 직후 UICon, CashStore, SpriteAtlas 번들 다운로드 및 캐싱. (SpriteAtlas 15MB 적재)<br>
                &nbsp;&nbsp; - ex1) Inventory UI Open → UICon.asset에 포함된 SpriteAtlas 적재 (+15MB)<br>
                &nbsp;&nbsp; - ex2) 이어서 CashStore UI Open → CashStore.asset에 포함된 SpriteAtlas 적재 (+15MB)</p>
                <p><strong>SpriteAtlas</strong>의 메모리만 총 <strong>45MB</strong> 사용.</p>
                <h5>개선 내용</h5>
                <p>① <strong>SpriteAtlas.asset</strong>에 포함될 .spriteatlas들의 Include Build = false; 로 수정</p>
                <img src="images/SpriteAtlas_LateBinding_개선_내용1.png" alt="빌드 포함 여부 수정" class="clickable-image">
                <p class="ref-note">*빌드 포함 여부</p>
                <p>② 번들을 다운로드 하기 전에 <strong>SpriteAtlas 이벤트</strong>를 추가합니다.</p>
                <img src="images/SpriteAtlas_LateBinding_개선_내용2.png" alt="SpriteAtlas 이벤트 추가" class="clickable-image">
                <p class="ref-note">*spriteAtlasManager.atlasRequested : 객체가 .spriteatlas를 참조하지만 찾지 못할 때 호출 이벤트</p>
                <p>③ 번들 다운로드 받고 캐싱 후 타 번들이 .spriteAtlas를 찾지 못하도록 <strong>bundle.Unload(false)</strong></p>
                <h5>결과</h5>
                <p>총 메모리 사용량 68.4MB → 11.9MB 로 최적화 (<strong>약 56.5MB 절감</strong>)</p>
                <img src="images/SpriteAtlas_LateBinding_결과.png" alt="LateBinding 결과" class="clickable-image">
                <div class="result-comparison">
                    <div><strong>LateBinding 이전</strong><p>IconAtlas * 24ea / BgAtlas * 8ea / SpriteAtlas * 6ea<br>- UICon.asset만을 사용했을 뿐인데 Texture2D만 <strong>68MB</strong> 증가<br>- Icon, Bg, Sprite Atlas가 추가되어 기존에 있음에도 중복으로 적재</p></div>
                    <div><strong>LateBinding 이후</strong><p>IconAtlas * 8ea / BgAtlas * 4ea / SpriteAtlas * 3ea<br>- UICon, CashShop.asset을 사용해도 atlas의 증가 없음</p></div>
                </div>
                <h5>사용 기술</h5>
                <ul><li><strong>SpriteAtlasManager.atlasRequested</strong></li><li><strong>AssetBundle.Unload</strong></li><li>Unity <strong>SpriteAtlas Late Binding</strong> (cc - Manual)</li></ul>
            </div>
        
            <div id="opt-tab-2" class="modal-tab-content">
                <h4>2. SharedMap SpriteAtlas</h4>
                <h5>문제점</h5>
                <img src="images/SharedMap_SpriteAtlas_문제점.png" alt="SharedMap SpriteAtlas 문제점" class="clickable-image">
                <ul><li>각 맵마다 별도 Sprite 폴더 및 SpriteAtlas를 사용하고 있음에도, 실제 게임 실행 시 다른 맵의 SpriteAtlas가 참조되어 <strong>불필요한 중복 로딩</strong> 발생.</li><li>맵 제작 시 여러 맵에서 사용되는 하나의 맵 프리팹 사용으로 인한 <strong>SpriteAtlas 중복 적재</strong> 확인.</li></ul>
                <h5>개선 내용</h5>
                <p><strong>중복 방지 툴</strong>을 실행하여 공용으로 사용하는 Sprite들을 모아 <strong>SharedMap_SpriteAtlas.spriteatals</strong>를 제작하고, 각 맵 Prefab의 참조를 수정.</p>
                <img src="images/SharedMap_SpriteAtlas_개선_내용.png" alt="SharedMap SpriteAtlas 개선 내용" class="clickable-image">
                <h5>결과</h5>
                <p>Texture 메모리 사용량 <strong>25.2MB → 14.4MB</strong> (약 10.8MB 감소)</p><img src="images/SharedMap_SpriteAtlas_결과1.png" alt="SharedMap SpriteAtlas 결과1" class="clickable-image">
                <p>전체 메모리 사용량 <strong>1.39GB → 1.31GB</strong> (약 88MB 절감)</p><img src="images/SharedMap_SpriteAtlas_결과2.png" alt="SharedMap SpriteAtlas 결과2" class="clickable-image">
                <h5>사용 기술</h5><ul><li><strong>Memory Profiler</strong>, <strong>Custom Editor Tool</strong></li><li><strong>AssetBundle</strong></li></ul>
            </div>
        
            <div id="opt-tab-3" class="modal-tab-content">
                <h4>3. Tilemap Property 중복 적재 제거</h4>
                <h5>문제점</h5>
                <img src="images/Tilemap_Property_중복_적재_제거_문제.png" alt="Tilemap Property 문제" class="clickable-image">
                <p>맵 이동 시 이전 맵의 Resource들이 해제되지 않고 누적되어 <strong>최대 208MB까지 중복 적재</strong>되는 현상 발생.</p>
                <h5>개선 내용</h5>
                <img src="images/Tilemap_Property_중복_적재_제거_개선_내용.png" alt="Tilemap Property 개선 내용" class="clickable-image">
                <p><strong>AssetBundle</strong> 로드 시에도 메모리에 적재됨을 확인. 적재된 메모리를 <strong>null처리</strong>로 Reference Count 감소 후, <strong>UnloadUnusedAssets</strong> 함수로 제거하여 이중 적재 및 누적 문제 해결.</p>
                <h5>결과</h5>
                <p>이전 맵 리소스 누적 문제 제거. 30~50MB 누적 → <strong>약 7.7MB만 사용</strong>.</p><img src="images/Tilemap_Property_중복_적재_제거_결과1.png" alt="Tilemap Property 결과1" class="clickable-image">
                <p>맵 6개 이동 시 메모리 증가량 비교: 최적화 전 60MB 증가 → <strong>최적화 후 30MB 감소</strong>.</p><img src="images/Tilemap_Property_중복_적재_제거_결과2.png" alt="Tilemap Property 결과2" class="clickable-image">
                <h5>사용 기술</h5><ul><li><strong>Memory Profiler</strong></li><li><strong>AssetBundle</strong>, <strong>Resources.UnloadUnusedAssets</strong></li></ul>
            </div>
        
            <div id="opt-tab-4" class="modal-tab-content">
                <h4>4. 상시 적재되지만 사용하지 않는 AssetBundle 제거</h4>
                <h5>문제점</h5>
                <p>Login Scene에서만 필요한 AssetBundle(영상, UI 등)이 게임 플레이 중에도 상시 메모리에 적재됨. <strong>RenderTexture</strong>의 명시적인 해제 처리 미흡.</p>
                <h5>개선 내용</h5>
                <p>기존 AssetBundle 캐싱 방식을 <strong>GameObject에서 AssetBundle 자체로 변경</strong>. 실제 사용 시에만 GameObject로 변환하여 사용. <strong>RenderTexture.Release()</strong>를 통해 메모리 해제.</p>
                <h5>결과</h5>
                <img src="images/상시_적재되지만_사용하지_않는_AssetBundle_제거.png" alt="AssetBundle 제거 결과" class="clickable-image">
                <p>Login 전용 번들의 불필요한 상시 메모리 점유 해제로 Render Texture 메모리 해제. (<strong>-23.7MB</strong>)</p>
                <h5>사용 기술</h5><ul><li><strong>Memory Profiler</strong></li><li><strong>AssetBundle</strong>, <strong>Resources.UnloadUnusedAssets</strong></li><li><strong>VideoPlayer</strong>, <strong>RenderTexture.Release()</strong></li></ul>
            </div>
        
            <div id="opt-tab-5" class="modal-tab-content">
                <h4>5. Big Size Texture 분류 및 번들화</h4>
                <h5>문제점</h5>
                <img src="images/Big_Size_Texture_분류_및_번들화.png" alt="Big Size Texture 문제점" class="clickable-image">
                <p>SpriteAtlas 한 페이지 전체를 차지하는 고해상도 Texture 다수 발견. Atlas에 포함 시 Batch 수 감소 효과가 없고 불필요하게 Bundle 크기만 증가.</p>
                <h5>개선 내용</h5>
                <p>비효율적인 Sprite들을 선발하여, 큰 이미지들로만 구성된 별도의 <strong>AssetBundle</strong>로 번들화 진행.</p>
                <h5>결과</h5>
                <p>29페이지의 SpriteAtlas를 4페이지로 줄이며 Bache 수 감소 및 메모리 약 2~5MB 절감. 번들 사이즈 <strong>52.2MB → 7.2MB</strong>.</p>
            </div>
        </div>
        </div>

    <footer>
        <p>&copy; 2025 임종훈. All rights reserved.</p>
    </footer>

    <script>
        // 모달 스크립트 (탭 기능 추가)
        document.addEventListener('DOMContentLoaded', function () {
            const modal = document.getElementById('myModal');
            const modalContent = document.querySelector('.modal-content');
            const modalDynamicContent = document.getElementById('modal-dynamic-content');
            const closeButton = document.querySelector('.close-button');
            const taskButtons = document.querySelectorAll('.task-button');

            if (!modal || !modalContent || !closeButton || !taskButtons) { return; }

            taskButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const contentId = button.getAttribute('data-content-id');
                    const contentSource = document.getElementById(contentId);

                    if (contentSource) {
                        modalDynamicContent.innerHTML = contentSource.innerHTML;

                        const align = contentSource.getAttribute('data-align');
                        if (align === 'left') { modalContent.classList.add('text-left'); } 
                        else { modalContent.classList.remove('text-left'); }

                        modal.style.display = 'flex';

                        // ▼▼▼ 탭 기능 활성화 함수 호출 ▼▼▼
                        initializeModalTabs();
                    }
                });
            });

            // ▼▼▼ 모달 내부의 탭 기능을 초기화하는 함수 ▼▼▼
            function initializeModalTabs() {
                const tabs = modal.querySelectorAll('.modal-tabs li');
                const tabContents = modal.querySelectorAll('.modal-tab-content');

                if (tabs.length === 0) return; // 탭이 없으면 실행 안함

                tabs.forEach(tab => {
                    tab.addEventListener('click', () => {
                        // 모든 탭과 콘텐츠에서 active 클래스 제거
                        tabs.forEach(t => t.classList.remove('active'));
                        tabContents.forEach(c => c.classList.remove('active'));

                        // 클릭된 탭과 연결된 콘텐츠에 active 클래스 추가
                        tab.classList.add('active');
                        const targetId = tab.getAttribute('data-target');
                        const targetContent = modal.querySelector('#' + targetId);
                        if (targetContent) {
                            targetContent.classList.add('active');
                        }
                    });
                });
            }

            const closeModal = () => { modal.style.display = 'none'; };
            closeButton.addEventListener('click', closeModal);
            window.addEventListener('click', (event) => { if (event.target == modal) { closeModal(); } });
            window.addEventListener('keydown', (event) => { if (event.key === 'Escape') { closeModal(); } });
        });
        // 사이드 메뉴 스크립트
        document.addEventListener('DOMContentLoaded', function() {
            const sections = document.querySelectorAll('.content-section');
            const navLinks = document.querySelectorAll('.side-nav a');
            if (sections.length === 0 || navLinks.length === 0) return;
            const observer = new IntersectionObserver(entries => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        navLinks.forEach(link => {
                            link.classList.remove('active');
                            if (link.getAttribute('href').substring(1) === entry.target.id) {
                                link.classList.add('active');
                            }
                        });
                    }
                });
            }, { rootMargin: '-50% 0px -50% 0px' });
            sections.forEach(section => { observer.observe(section); });
        });
        // 이미지 라이트박스 스크립트
        document.addEventListener('DOMContentLoaded', function() {
            const imageModal = document.getElementById('imageModal');
            const largeImage = document.getElementById('largeImage');
            const closeImageModalButton = document.querySelector('.close-image-modal');
            if (!imageModal || !largeImage || !closeImageModalButton) return;
            document.body.addEventListener('click', function(event) {
                if (event.target.classList.contains('clickable-image')) {
                    imageModal.style.display = 'flex';
                    largeImage.src = event.target.src;
                }
            });
            const closeImageModal = () => { imageModal.style.display = 'none'; };
            closeImageModalButton.addEventListener('click', closeImageModal);
            imageModal.addEventListener('click', (event) => { if (event.target === imageModal) { closeImageModal(); } });
            window.addEventListener('keydown', (event) => { if (event.key === 'Escape') { closeImageModal(); }});
        });
    </script>
</body>
</html>