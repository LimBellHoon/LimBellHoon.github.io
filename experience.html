<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>임종훈의 포트폴리오 - 경력 기술</title>
    <link rel="stylesheet" href="css/style.css">
    <style>
	.modal-hidden-content { display: none !important; }
	.section-title { margin-bottom: 10px; }
	.project-description h3 { margin-bottom: 1px; }
	.project-description .project-date { margin-top: 0px; }
	.section-subtitle { margin-bottom: 20px; }
	.modal-tabs li { position: relative; }
	.modal-tabs li.active { border-bottom-color: transparent !important; }
	.modal-tabs li::after { 
		content: '';
		display: block;
		position: absolute;
		left: 15px;
		right: 15px;
		bottom: -1px;
		height: 3px;
		background-color: transparent;
		transition: background-color 0.2s ease-in-out;
	}
	.modal-tabs li.active::after { background-color: var(--primary-color); }
	.modal-tabs li:not(:first-child)::before { content: none; }
	.modal-tab-content h4:not(:first-of-type) { border-top: 1px solid var(--border-color); padding-top: 25px; margin-top: 25px; }
	.modal-tab-content img { max-width: 100%; height: auto; }
	.parenthesis-note { font-size: 0.9em; }
	.mt-30 { margin-top: 30px; }
	.modal-tab-content img.clickable-image { margin-bottom: 0; }
	.modal-tab-content p.ref-note { margin-top: -5px; font-size: 0.9em; color: #6c757d; }
	.modal-tab-content > p,
	.modal-tab-content > ul,
	.modal-tab-content > div { margin-left: 20px; }
	.modal-tab-content > *:not(h3):not(h4) { margin-left: 20px; }
	.modal-tab-content > p:not(.ref-note) { margin-bottom: 5px; }
    </style>
</head>
<body class="sub-page">

    <nav class="navbar">
        <ul>
            <li><a href="index.html">내 소개</a></li>
            <li><a href="experience.html" class="active">경력 기술</a></li>
            <li><a href="portfolio.html">포트폴리오</a></li>
            <li><a href="contact.html">Contact</a></li>
        </ul>
    </nav>
    
    <div class="page-container">
        
        <aside class="side-nav">
            <ul>
                <li><a href="#experience-projects" class="active">프로젝트</a></li>
                <li><a href="#experience-details">경력 기술</a></li>
                <li><a href="#version-control">형상 관리</a></li>
            </ul>
        </aside>

        <main class="main-content">
            <div class="page-header"><h1>경력 기술</h1></div>
            
            <section id="experience-projects" class="content-section">
                <h2 class="section-title">프로젝트</h2><p class="section-subtitle">수행한 주요 프로젝트를 소개합니다.</p>
                
                <div class="project-item">
                    <div class="project-image"><img src="images/metin.jpg" alt="메틴 파멸의 서곡"></div>
                    <div class="project-description">
                        <h3>메틴: 파멸의 서곡</h3><p class="project-date">2024.05 - Ing</p>
                        <p><strong>유니티로 개발한 리니지 라이크 장르</strong>의 신규 모바일 프로젝트에 참여했습니다. 주된 업무로는 <strong>SDK 및 최적화</strong>와 <strong>빌드</strong>를 담당했습니다.</p>
                        <p>출시 이후에는 인게임 <strong>콘텐츠 개발 및 유지보수 업무를 담당</strong>하고 있습니다.</p>
                        <div class="project-details">
                            <div><h4>SDK</h4><ul><li>Firebase-Auth/Messaging</li><li>Adjust, AIHelp</li></ul></div>
                            <div><h4>콘텐츠</h4><ul><li>코스튬</li><li>공성전</li><li>월드 던전, 공성 던전</li><li>랭킹 시스템</li><li>허수아비 수련 시스템</li><li>칭호 시스템</li></ul></div>
                            <div><h4>빌드</h4><ul><li>One, Galaxy, Play Unity 빌드</li><li>IOS XCode 빌드</li></ul></div>
                            <div><h4>최적화</h4><ul><li>LateBinding/메모리 중복 제거</li><li>DrawCall 최적화</li></ul></div>
                        </div>
                    </div>
                </div>

                <div class="project-item reverse">
                    <div class="project-image"><img src="images/cheonsangbi.png" alt="천상비M"></div>
                    <div class="project-description">
                        <h3>천상비M</h3><p class="project-date">2023.09 - 2024.05</p>
                        <p><strong>C#</strong>, <strong>유니티</strong>로 개발한 <strong>리니지라이크</strong> 장르의 모바일 프로젝트에 참여했습니다. 주된 업무로는 <strong>유지보수</strong> 및 <strong>콘텐츠 개발</strong>, <strong>빌드</strong>를 담당했습니다.</p>
                        <div class="project-details">
                            <div><h4>콘텐츠 개발</h4><ul><li>이벤트 제작</li><li>NPC 우호도/파견</li><li>강화 도감</li><li>사냥/장비 도감 작업</li><li>캐시 일괄 구매</li></ul></div>
                            <div><h4>빌드</h4><ul><li>One, Galaxy, Play Unity 빌드</li><li>IOS XCode 빌드</li></ul></div>
                            <div><h4>유지보수 작업</h4><ul><li>CS 처리</li><li>해외 서비스를 위한 Localization</li></ul></div>
                        </div>
                    </div>
                </div>
            </section>

	<section id="experience-details" class="content-section">
                <hr class="section-divider">
		<h2 class="section-title">경력 기술</h2><p class="section-subtitle">버튼을 클릭하면 해당 상세 팝업이 열립니다.</p>
                <div class="task-section">
                    <div class="task-grid">
                        <div class="task-button" data-content-id="optimization-content"><div class="circle"><span>최적화</span></div><div class="task-label"><h4>최적화</h4><p>최적화: 1.77GB → 1.22GB</p></div></div>
                        <div class="task-button" data-content-id="sdk-content"><div class="circle"><span>SDK</span></div><div class="task-label"><h4>SDK</h4><p>Firebase/Adjust</p></div></div>
                        <div class="task-button" data-content-id="build-content"><div class="circle"><span>Build</span></div><div class="task-label"><h4>빌드</h4><p>AOS/IOS</p></div></div>
                        <div class="task-button" data-content-id="contents-content"><div class="circle"><span>Contents</span></div><div class="task-label"><h4>콘텐츠</h4><p>인게임 시스템 개발</p></div></div>
                    </div>
                </div>
            </section>

            <section id="version-control" class="content-section">
                <hr class="section-divider"><h2 class="section-title">형상 관리</h2>
                <div class="project-item">
                    <div class="project-image"><img src="images/version-control.png" alt="형상 관리"></div>
                    <div class="project-description">
                        <h4><strong>Tortoise SVN</strong></h4>
                        <p>현재 회사 프로젝트의 형상 관리를 <strong>Tortoise SVN</strong>을 통해 수행하고 있습니다. <strong>GitHub</strong>와는 달리 로컬 저장소를 지원하지 않아 중앙 서버 의존성이 있지만, 변경 이력 추적과 기존 코드와의 비교가 간편하다는 장점이 있습니다.</p>
                        <p>형상 관리의 효율성을 높이기 위해, 빌드 과정에서 자동으로 최신 코드로 업데이트할 수 있는 간단한 <strong>배치 파일</strong>을 제작하여 <strong>SVN 업데이트를 자동화</strong>했습니다. 이를 통해 형상 관리의 편의성과 일관성을 높였습니다.</p>
                        <h4 class="mt-30"><strong>GitHub</strong></h4>
                        <p>개인 및 팀 프로젝트를 진행할 때 사용하는 형상관리 툴입니다. 특히 팀 프로젝트 진행 시, <strong>브랜치</strong>를 사용한 작업 분리가 용이하여 기능별 작업 관리와 <strong>병합 기능</strong>이 직관적이고 용이했습니다.</p>
                        <p>또한, 로컬 저장소에 저장 후 커밋 후 원하는 시점에 <strong>Push</strong>할 수 있어, 불필요한 <strong>Conflict를 줄이고</strong> 안정적인 개발 환경을 유지할 수 있었습니다.</p>
                    </div>
                </div>
            </section>
        </main>
    </div>

    <div id="myModal" class="modal-overlay">
        <div class="modal-content"><span class="close-button">&times;</span><div id="modal-dynamic-content"></div></div>
    </div>

    <div id="imageModal" class="image-modal-overlay">
        <span class="close-image-modal">&times;</span>
        <img class="image-modal-content" id="largeImage">
    </div>

	<div class="modal-hidden-content">
		<div id="optimization-content" data-align="left">
			<h2>최적화</h2>
				<ul class="modal-tabs">
					<li class="active" data-target="opt-tab-1">LateBinding</li>
					<li data-target="opt-tab-2">SharedMap</li>
					<li data-target="opt-tab-3">Tilemap</li>
					<li data-target="opt-tab-4">AssetBundle</li>
					<li data-target="opt-tab-5">Big Texture</li>
				</ul>
			<div class="modal-tab-container">
			<div id="opt-tab-1" class="modal-tab-content active">
                <h3>SpriteAtlas LateBinding</h3>
                <h4>문제점</h4>
                <p>Bundle 사용 시, 이미지를 <strong>SpriteAtlas.asset</strong>이 아닌 Bundle에 포함된 <strong>SpriteAtlas</strong>에서 직접 참조하여 <strong>SpriteAtlas</strong>가 메모리에 중복 적재되는 문제를 발견했습니다.</p>
                <p style="padding-left: 1em; text-indent: -1em;"><b>문제 상황 :</b> 게임 실행 직후 UICon, CashStore, SpriteAtlas 번들 다운로드 및 캐싱. (SpriteAtlas 15MB 적재)<br>
                &nbsp;&nbsp; - ex1) Inventory UI Open → UICon.asset에 포함된 SpriteAtlas 적재 (+15MB)<br>
                &nbsp;&nbsp; - ex2) 이어서 CashStore UI Open → CashStore.asset에 포함된 SpriteAtlas 적재 (+15MB)</p>
                <p>이로 인해 <strong>SpriteAtlas</strong>에서만 총 <strong>45MB</strong>의 메모리가 중복 사용되었습니다.</p>
                <h4>개선 내용</h4>
                <p>① <strong>SpriteAtlas.asset</strong>에 포함될 .spriteatlas들의 Include Build = false; 로 수정했습니다.</p>
                <img src="images/SpriteAtlas_LateBinding_개선_내용1.png" alt="빌드 포함 여부 수정" class="clickable-image">
                <p class="ref-note">*빌드 포함 여부</p>
                <p>② 번들을 다운로드 하기 전에 <strong>SpriteAtlas 이벤트</strong>를 추가합니다.</p>
                <img src="images/SpriteAtlas_LateBinding_개선_내용2.png" alt="SpriteAtlas 이벤트 추가" class="clickable-image">
                <p class="ref-note">*spriteAtlasManager.atlasRequested : 객체가 .spriteatlas를 참조하지만 찾지 못할 때 호출 이벤트</p>
                <p>③ 번들 다운로드 받고 캐싱 후 타 번들이 .spriteAtlas를 찾지 못하도록 <strong>bundle.Unload(false)</strong>를 호출합니다.</p>
                <h4>결과</h4>
                <p>총 메모리 사용량 68.4MB → 11.9MB 로 최적화 (<strong>약 56.5MB 절감</strong>)</p>

		<div><strong>LateBinding 이전</strong> <span class="parenthesis-note">(IconAtlas * 24ea / BgAtlas * 8ea / SpriteAtlas * 6ea)</span>
                <img src="images/SpriteAtlas_LateBinding_결과1.png" alt="LateBinding 결과" class="clickable-image">
                
                - UICon.asset 하나만 사용했음에도 Texture2D 메모리가 <strong>68MB</strong> 증가했으며, 이는 기존에 로드된 Atlas들이 중복 적재되었음을 의미합니다.</div>
		

		<br>


		<strong>LateBinding 이후</strong><span class="parenthesis-note">(IconAtlas * 8ea / BgAtlas * 4ea / SpriteAtlas * 3ea)</span>
                <img src="images/SpriteAtlas_LateBinding_결과2.png" alt="LateBinding 결과" class="clickable-image">
                
                <h4>사용 기술</h4>
                <ul><li><strong>SpriteAtlasManager.atlasRequested</strong></li><li><strong>AssetBundle.Unload</strong></li><li>Unity <strong>SpriteAtlas Late Binding</strong> (cc - Manual)</li></ul>
            </div>
        
            <div id="opt-tab-2" class="modal-tab-content">
                <h3>SharedMap SpriteAtlas</h3>
                <h4>문제점</h4>
                <img src="images/SharedMap_SpriteAtlas_문제점.png" alt="SharedMap SpriteAtlas 문제점" class="clickable-image">
                <ul><li>각 맵마다 별도 Sprite 폴더 및 SpriteAtlas를 사용하고 있음에도, 실제 게임 실행 시 다른 맵의 SpriteAtlas가 참조되어 <strong>불필요한 중복 로딩</strong>이 발생했습니다.</li><li>맵 제작 시 여러 맵에서 사용되는 하나의 맵 프리팹 사용으로 인한 <strong>SpriteAtlas 중복 적재</strong>를 확인했습니다.</li></ul>
                <h4>개선 내용</h4>
                <p><strong>중복 방지 툴</strong>을 실행하여 공용으로 사용하는 Sprite들을 모아 <strong>SharedMap_SpriteAtlas.spriteatals</strong>를 제작하고, 각 맵 Prefab의 참조를 수정했습니다.</p>
                <img src="images/SharedMap_SpriteAtlas_개선_내용.png" alt="SharedMap SpriteAtlas 개선 내용" class="clickable-image">
                <h4>결과</h4>
                <p>Texture 메모리 사용량 <strong>25.2MB → 14.4MB</strong> (약 10.8MB 감소)</p><img src="images/SharedMap_SpriteAtlas_결과1.png" alt="SharedMap SpriteAtlas 결과1" class="clickable-image">
                <p>전체 메모리 사용량 <strong>1.39GB → 1.31GB</strong> (약 88MB 절감)</p><img src="images/SharedMap_SpriteAtlas_결과2.png" alt="SharedMap SpriteAtlas 결과2" class="clickable-image">
                <h4>사용 기술</h4><ul><li><strong>Memory Profiler</strong>, <strong>Custom Editor Tool</strong></li><li><strong>AssetBundle</strong></li></ul>
            </div>
        
            <div id="opt-tab-3" class="modal-tab-content">
                <h3>Tilemap Property 중복 적재 제거</h3>
                <h4>문제점</h4>
                <img src="images/Tilemap_Property_중복_적재_제거_문제.png" alt="Tilemap Property 문제" class="clickable-image">
                <p>맵 이동 시 이전 맵의 Resource들이 해제되지 않고 누적되어 <strong>최대 208MB까지 중복 적재</strong>되는 현상이 발생했습니다.</p>
                <h4>개선 내용</h4>
                <img src="images/Tilemap_Property_중복_적재_제거_개선_내용.png" alt="Tilemap Property 개선 내용" class="clickable-image">
                <p><strong>AssetBundle</strong> 로드 시에도 메모리에 적재됨을 확인했습니다. 적재된 메모리를 <strong>null처리</strong>로 Reference Count 감소 후, <strong>UnloadUnusedAssets</strong> 함수로 제거하여 이중 적재 및 누적 문제를 해결했습니다.</p>
                <h4>결과</h4>
                <p>이전 맵 리소스 누적 문제 제거. 30~50MB 누적 → <strong>약 7.7MB만 사용</strong>.</p><img src="images/Tilemap_Property_중복_적재_제거_결과1.png" alt="Tilemap Property 결과1" class="clickable-image">
                <p>맵 6개 이동 시 메모리 증가량 비교: 최적화 전 60MB 증가 → <strong>최적화 후 30MB 감소</strong>.</p><img src="images/Tilemap_Property_중복_적재_제거_결과2.png" alt="Tilemap Property 결과2" class="clickable-image">
                <h4>사용 기술</h4><ul><li><strong>Memory Profiler</strong></li><li><strong>AssetBundle</strong>, <strong>Resources.UnloadUnusedAssets</strong></li></ul>
            </div>
        
            <div id="opt-tab-4" class="modal-tab-content">
                <h3>상시 적재되지만 사용하지 않는 AssetBundle 제거</h3>
                <h4>문제점</h4>
                <p>Login Scene에서만 필요한 AssetBundle(영상, UI 등)이 게임 플레이 중에도 상시 메모리에 적재되는 문제를 발견했습니다. <strong>RenderTexture</strong>의 명시적인 해제 처리가 미흡한 점을 확인했습니다.</p>
                <h4>개선 내용</h4>
                <p>기존 AssetBundle 캐싱 방식을 <strong>GameObject에서 AssetBundle 자체로 변경</strong>했습니다. 실제 사용 시에만 GameObject로 변환하여 사용하도록 구조를 변경했습니다. <strong>RenderTexture.Release()</strong>를 통해 메모리를 명시적으로 해제했습니다.</p>
                <h4>결과</h4>
                <img src="images/상시_적재되지만_사용하지_않는_AssetBundle_제거.png" alt="AssetBundle 제거 결과" class="clickable-image">
                <p>Login 전용 번들의 불필요한 상시 메모리 점유 해제로 Render Texture 메모리 해제. (<strong>-23.7MB</strong>)</p>
                <h4>사용 기술</h4><ul><li><strong>Memory Profiler</strong></li><li><strong>AssetBundle</strong>, <strong>Resources.UnloadUnusedAssets</strong></li><li><strong>VideoPlayer</strong>, <strong>RenderTexture.Release()</strong></li></ul>
            </div>
        
            <div id="opt-tab-5" class="modal-tab-content">
                <h3>Big Size Texture 분류 및 번들화</h3>
                <h4>문제점</h4>
                <img src="images/Big_Size_Texture_분류_및_번들화.png" alt="Big Size Texture 문제점" class="clickable-image">
                <p>SpriteAtlas 한 페이지 전체를 차지하는 고해상도 Texture를 다수 발견했습니다. Atlas에 포함 시 <strong>Batch</strong> 수 감소 효과가 없고 불필요하게 Bundle 크기만 증가시키는 문제를 확인했습니다.</p>
                <h4>개선 내용</h4>
                <p>비효율적인 Sprite들을 선별하여, 큰 이미지들로만 구성된 별도의 <strong>AssetBundle</strong>로 번들화를 진행했습니다.</p>
                <h4>결과</h4>
                <p>29페이지의 SpriteAtlas를 4페이지로 줄이며 <strong>Batch</strong> 수 감소 및 메모리 약 2~5MB 절감. 번들 사이즈 <strong>52.2MB → 7.2MB</strong>.</p>
            </div>
        </div>
        </div>



<div id="sdk-content" data-align="left">
	<h2>SDK</h2>
		<ul class="modal-tabs">
			<li class="active" data-target="sdk-tab-1">Firebase Login</li>
			<li data-target="sdk-tab-2">Firebase Push</li>
			<li data-target="sdk-tab-3">Adjust</li>
		</ul>
	<div class="modal-tab-container">
		<div id="sdk-tab-1" class="modal-tab-content active">
			<h3>Firebase 소셜 로그인 기능 구현 (Google, Apple, Guest)</h3>
			<h4>개발 목표</h4>
			<ul>
				<li>AOS 및 iOS 환경에서 최신 Firebase SDK를 사용하여 Google, Apple, Guest 로그인 기능을 통합 구현</li>
				<li>SDK 의존성 관리 및 플랫폼별 로그인 흐름을 일관성 있게 유지</li>
			</ul>
			<h4>구현 방식</h4>
			<ul>
				<li>기존 `.unitypackage` 방식의 SDK를 `.tgz` (UPM) 방식으로 마이그레이션하여 의존성 관리를 용이하게 했습니다.</li>
				<li>이를 통해 향후 구글 정책(예: 16KB 메모리 지원) 변경에 따른 SDK 버전 업그레이드에 신속하게 대응할 수 있는 기반을 마련했습니다.</li>
			</ul>
			<h4>플랫폼별 구현 세부 내용</h4>
			<ul>
				<li>AOS : Unity AOS SDK</li>
				<li>IOS : Unity IOS SDK</li>
			</ul>
		</div>
		
		<div id="sdk-tab-2" class="modal-tab-content">
			<h3>Firebase Push Messaging 기능 구현</h3>
			<h4>개발 목표</h4>
			<ul>
				<li>Android 및 iOS 플랫폼에서 Firebase Cloud Messaging(FCM)을 활용한 푸시 알림 수신 기능 구현</li>
				<li>플랫폼별 정책(권한) 변경에 유연하게 대응하고 안정적인 알림 시스템 구축</li>
			</ul>
			<h4>구현 방식</h4>
			<ul>
				<li>Firebase SDK 최신 버전 사용 (.tgz 방식)</li>
				<li>AOS: AndroidManifest에 FCM 관련 권한 및 서비스 등록</li>
				<li>IOS: APNs 인증 키 연동 및 Xcode 프로젝트 설정, 백그라운드/종료 상태 수신 처리 구현</li>
			</ul>
			<h4>주요 문제 해결</h4>
			<ul>
				<li><strong>iOS 플랫폼 Firebase Messaging 활성화:</strong> 입사 당시 iOS 플랫폼에서 FCM이 동작하지 않아 사용이 제한되던 문제를 해결했습니다. APNs 인증서 및 Xcode 프로젝트 설정을 재구성하고 초기화 로직을 수정하여, 프로젝트 전사적으로 iOS 푸시 알림 기능을 활성화시켰습니다.</li>
				<li><strong>Android 최신 API 레벨 대응:</strong> 기존 Android 13(API 33) 대응을 넘어, API 34, 35로 업그레이드하는 과정에서 발생하는 푸시 알림 권한 누락 문제를 해결하여 최신 OS 환경에서의 알림 수신 안정성을 확보했습니다.</li>
			</ul>
		</div>

		<div id="sdk-tab-3" class="modal-tab-content">
			<h3>Adjust (광고 성과 측정)</h3>
			<h4>개발 목표</h4>
			<ul>
				<li>Adjust SDK를 Unity 프로젝트에 연동하여, 광고 유입 분석 및 앱 내 사용자 행동 이벤트 트래킹 기능 구현</li>
				<li>마케팅 채널별 성과 측정을 위한 어트리뷰션 데이터 수집 및 전송 자동화</li>
			</ul>
			<h4>구현 방식</h4>
			<ul>
				<li>Adjust 공식 Unity SDK를 .unitypackage로 설치하여 Android/iOS 환경 모두 지원</li>
				<li>앱 실행 시 Adjust 자동 초기화 처리</li>
				<li>주요 인앱 이벤트 (회원가입, 튜토리얼 완료, 결제 등)에 대해 Adjust 이벤트 전송 로직 유닛화</li>
			</ul>
			<h4>주요 문제 해결</h4>
			<ul>
				<li><strong>iOS 광고 추적 정확도 개선 (ATT):</strong> Adjust SDK가 연동되어 있었으나, iOS의 앱 추적 투명성(ATT) 권한 요청 로직이 누락되어 마케팅 데이터가 정확히 집계되지 않는 문제를 발견했습니다. 앱 실행 시점에 ATT 권한 팝업을 노출하도록 플로우를 수정하여 광고 성과 측정의 정확도를 확보했습니다.</li>
			</ul>
		</div>
	</div>
</div>






<div id="build-content" data-align="left">
			<h2>빌드</h2>
			<ul class="modal-tabs">
				<li class="active" data-target="build-tab-1">빌드 설정 자동화 (Editor Tool)</li> <li data-target="build-tab-2">Xcode 프로젝트 자동 설정 (PostProcess)</li> <li data-target="build-tab-3">IOS 배포 프로세스</li> </ul>
			<div class="modal-tab-container">
				<div id="build-tab-1" class="modal-tab-content active"> <h3>빌드 설정 자동화 (Editor Tool)</h3>
					<h4>개발 목표</h4>
					<ul>
						<li>Unity Editor 내에서 빌드 관련 <strong>주요 설정(버전, 서버 타입 등)을 간편하게 관리</strong>하고 적용하는 프로세스 자동화.</li>
						<li>수동 설정으로 인한 <strong>휴먼 에러를 줄이고 빌드 준비 시간을 단축</strong>.</li>
						<li>SVN 리비전 자동 조회 등 <strong>빌드 정보의 정확성 확보</strong>.</li>
					</ul>
					<h4>주요 기능 (BuildProcessEditorWindow.cs)</h4>
					<ul>
                        <li><strong>(선행 작업) SVN 업데이트 자동화</strong>: 별도의 .bat 스크립트 실행으로 빌드 전 TortoiseSVN을 통해 프로젝트 폴더 일괄 업데이트. </li>
						<li><strong>빌드 정보 관리</strong>: 서버 IP (라이브/QA), 번들 다운로드 방식, 시즌/클라이언트/스토어 버전 입력 및 관리.</li>
						<li><strong>SVN 리비전 자동 조회</strong>: `svn.exe info` 명령어를 외부 프로세스로 실행하여 `Assets/Scripts` 폴더의 'Last Changed Rev'를 자동으로 가져와 빌드 버전에 반영.</li>
						<li><strong>다음 빌드 설정 자동 계산</strong>: '다음 빌드 데이터 불러오기' 버튼으로 현재 설정 기준 다음 스토어 버전(+1, 옵션) 및 최신 SVN 리비전을 미리 계산하여 표시.</li>
						<li><strong>설정 일괄 적용</strong>: 에디터 창의 설정을 타겟 오브젝트(`SceneProcess`) 및 `PlayerSettings` (Android `bundleVersionCode`, `bundleVersion`, iOS `buildNumber`)에 한 번에 적용.</li>
						<li><strong>빌드 전 정리</strong>: `SpriteAtlas` 및 `StreamingAssets` 폴더 내용을 버튼 클릭으로 자동 삭제하여 깨끗한 빌드 환경 준비.</li>
						<li><strong>보안 설정</strong>: Android Keystore 및 Keyalias 비밀번호 설정 기능 제공.</li>
					</ul>
					<h4>자동화 프로세스 ("자동 빌드 세팅" 버튼)</h4>
					<ul>
						<img src="images/빌드 에디터 툴.png" alt="빌드 에디터 툴" class="clickable-image"> <p class="ref-note">*유니티 에디터 빌드 툴</p>
						<li><strong>원클릭 실행</strong>: 버튼 클릭 한 번으로 [다음 빌드 설정 계산 → 설정값 적용(SceneProcess, PlayerSettings) → 씬 저장 → 에셋 폴더 정리 → 비밀번호 설정]까지 빌드 전 필요한 모든 준비 단계를 순차적으로 자동 실행.</li>
						<li><strong>진행 상황 표시</strong>: `EditorUtility.DisplayProgressBar`를 사용하여 각 단계별 진행 상황을 사용자에게 시각적으로 안내.</li>
					</ul>
                    <h4>기대 효과</h4>
                    <ul>
                        <li>빌드 전 준비 과정의 복잡성 감소 및 소요 시간 단축.</li>
                        <li>버전 정보, 서버 설정 등 중요 설정 누락/오입력 방지.</li>
                        <li>팀 내 표준화된 빌드 준비 절차 확립에 기여.</li>
                    </ul>
				</div>

				<div id="build-tab-2" class="modal-tab-content"> <h3>Xcode 프로젝트 자동 설정 (PostProcess)</h3>
					<h4>개발 목표</h4>
					<ul>
						<li>Unity iOS 빌드 후 Xcode 프로젝트에 필요한 반복적인 설정 작업을 C# 스크립트로 자동화하여 빌드 시간 단축 및 오류 감소.</li>
					</ul>
					<h4>자동화 내용 (XcodePostProcess.cs)</h4>
					<ul>
						<li><strong>[PostProcessBuild]</strong> 어트리뷰트로 빌드 후 자동 실행.</li>
						<li><strong>필수 Framework 자동 추가</strong>: `PBXProject` API를 사용하여 `UserNotifications`, `StoreKit`, 광고 관련 프레임워크 등을 프로젝트에 자동으로 연결.</li>
						<li><strong>Capability 설정 자동화</strong>: `ProjectCapabilityManager`를 활용하여 `Sign in with Apple`, `Push Notifications`, `Background Modes` 등 필요한 기능을 자동으로 활성화.</li>
						<li><strong>Info.plist 자동 수정</strong>: `PlistDocument` API를 사용하여 ATT(앱 추적 투명성) 권한 문구, 카메라 사용 문구, 암호화 사용 여부 등 필요한 항목들을 자동으로 추가 및 수정.</li>
						<li><strong>Build Settings 자동 구성</strong>: `PBXProject` API를 사용하여 Architectures, Supported Platforms, Code Signing Identity 등 주요 빌드 옵션을 스크립트로 미리 설정.</li>
                        <li><strong>기타 처리</strong>: `GoogleService-Info.plist` 파일의 중복 포함 방지 등 빌드 과정의 자잘한 이슈들을 자동으로 처리.</li>
					</ul>
					<h4>기대 효과</h4>
					<ul>
						<li>Xcode 프로젝트 설정에 소요되는 수동 작업 시간 대폭 단축.</li>
						<li>설정 누락이나 실수로 인한 빌드 오류 가능성 감소.</li>
                        <li>팀 내 일관된 빌드 환경 유지에 기여.</li>
					</ul>
				</div>

<div id="build-tab-3" class="modal-tab-content"> <h3>IOS 배포 프로세스 관리</h3>
					<h4>개발 목표</h4>
					<ul>
						<li>TestFlight를 통한 내부/외부 테스트 빌드 프로세스 확립.</li>
						<li>App Store 최초 심사 및 업데이트 심사 통과를 위한 준비 및 대응 전략 수립.</li>
					</ul>
					<h4>주요 업무</h4>
					<ul>
						<li><strong>Provisioning Profile & Certificates 관리</strong>: Apple Developer 사이트에서 인증서 및 프로비저닝 프로파일(Development, Ad-Hoc, Distribution)을 발급하고 Xcode 프로젝트에 정확히 연동.</li>
						<li><strong>TestFlight 배포</strong>: Archive 완료 후 생성된 .ipa 파일을 Application Loader 또는 Xcode Organizer를 통해 TestFlight에 업로드하고 내부/외부 테스터 그룹에 배포하여 사전 검증 진행.</li>
						<li><strong>App Store 심사 제출 및 대응</strong>: 심사 제출 시 필요한 메타데이터(스크린샷, 설명 등)를 정확히 준비하고, 심사 과정 중 발생하는 리젝(Reject) 사유를 파악하고 신속하게 대응.</li>
					</ul>
                    <br> <h4>최초 심사 시 주요 유의사항 (경험 기반)</h4>
                    <ul>
                        <li><strong>앱 용량 및 데이터 다운로드 (Guideline 2.5)</strong>:
                            <ul style="padding-left: 20px;">
                                <li>빌드 용량 최소화: 초기 빌드(.ipa) 용량이 과도하게 크지 않도록 관리 (경험상 750MB 통과, 1GB 초과 시 다운로드 시간 문제 발생 가능성).</li>
                                <li>번들 다운로드 시간: 게임 시작 시 다운로드하는 번들 용량이 너무 크면 다운로드 시간 초과(경험상 2GB, 30분 이상 소요 시 리젝)로 리젝될 수 있음. → **해결**: 주요 아틀라스, UI 리소스 등 필수 번들은 Resources 폴더에 포함시켜 빌드하여 초기 다운로드 시간 단축.</li>
                            </ul>
                        </li>
                        <li><strong>콘텐츠 접근성 및 테스트 용이성 (Guideline 2.1)</strong>:
                            <ul style="padding-left: 20px;">
                                <li>튜토리얼 스킵 기능: 심사자가 모든 콘텐츠를 빠르게 테스트할 수 있도록 튜토리얼 스킵 버튼 제공 필수 (또는 튜토리얼 off 빌드, 스킵 계정 제공).</li>
                                <li>모든 콘텐츠 개방: 레벨 제한, 특정 조건 달성 등으로 잠겨 있는 콘텐츠 없이, 심사 시점에는 모든 메뉴와 기능에 접근 가능해야 함.</li>
                            </ul>
                        </li>
                        <li><strong>계정 관리 (Guideline 5.1.1)</strong>:
                            <ul style="padding-left: 20px;">
                                <li>계정 삭제 기능: 앱 내(ex: 로그인 화면)에 명확하게 보이는 계정 삭제 기능 필수 구현. (리뷰어가 못 찾을 시 스크린샷 첨부하여 회신)</li>
                                <li>로그인 옵션: 최소 2가지 이상의 소셜 로그인 + 게스트 로그인 기능 제공.</li>
                            </ul>
                        </li>
                        <li><strong>심사용 빌드 기능 제한</strong>:
                            <ul style="padding-left: 20px;">
                                <li>웹뷰/외부 SDK 비활성화: 도움말(웹뷰), 고객센터(AIHelp 등 외부 SDK 연동) 등 앱 외부로 연결되거나 외부 SDK UI가 직접 노출되는 기능은 심사 빌드에서 반드시 비활성화 처리. (UI 버튼 자체는 존재해도 무방하나, 기능적으로 동작하지 않아야 함)</li>
                                <li>쿠폰 등 특정 기능: 프로모션 코드 입력 등 일부 기능은 심사 시 제외 필요.</li>
                            </ul>
                        </li>
                        <li><strong>정확한 메타데이터 (Guideline 2.3.3)</strong>:
                            <ul style="padding-left: 20px;">
                                <li>스크린샷 일치: App Store Connect에 제출하는 미리보기 스크린샷은 반드시 심사용 빌드에서 접근 가능한 콘텐츠만을 포함해야 함 (미구현 콘텐츠 스크린샷 포함 시 리젝).</li>
                            </ul>
                        </li>
                    </ul>
                    <p style="font-size: 0.9em; color: #6c757d;">*상기 내용은 MetinM 출시 경험 기반이며, Apple 심사 지침은 변경될 수 있습니다.</p>
				</div>
			</div>
		</div>


				
				<div id="build-tab-2" class="modal-tab-content"> <h3>Xcode 프로젝트 자동 설정 (PostProcess)</h3>
					<h4>개발 목표</h4>
					<ul>
						<li>Unity iOS 빌드 후 Xcode 프로젝트에 필요한 반복적인 설정 작업을 C# 스크립트로 자동화하여 빌드 시간 단축 및 오류 감소.</li>
					</ul>
					<h4>자동화 내용 (XcodePostProcess.cs)</h4>
					<ul>
						<li><strong>[PostProcessBuild]</strong> 어트리뷰트로 빌드 후 자동 실행.</li>
						<li><strong>필수 Framework 자동 추가</strong>: `PBXProject` API를 사용하여 `UserNotifications`, `StoreKit`, 광고 관련 프레임워크 등을 프로젝트에 자동으로 연결.</li>
						<li><strong>Capability 설정 자동화</strong>: `ProjectCapabilityManager`를 활용하여 `Sign in with Apple`, `Push Notifications`, `Background Modes` 등 필요한 기능을 자동으로 활성화.</li>
						<li><strong>Info.plist 자동 수정</strong>: `PlistDocument` API를 사용하여 ATT(앱 추적 투명성) 권한 문구, 카메라 사용 문구, 암호화 사용 여부 등 필요한 항목들을 자동으로 추가 및 수정.</li>
						<li><strong>Build Settings 자동 구성</strong>: `PBXProject` API를 사용하여 Architectures, Supported Platforms, Code Signing Identity 등 주요 빌드 옵션을 스크립트로 미리 설정.</li>
                        <li><strong>기타 처리</strong>: `GoogleService-Info.plist` 파일의 중복 포함 방지 등 빌드 과정의 자잘한 이슈들을 자동으로 처리.</li>
					</ul>
					<h4>기대 효과</h4>
					<ul>
						<li>Xcode 프로젝트 설정에 소요되는 수동 작업 시간 대폭 단축.</li>
						<li>설정 누락이나 실수로 인한 빌드 오류 가능성 감소.</li>
                        <li>팀 내 일관된 빌드 환경 유지에 기여.</li>
					</ul>
				</div>
			</div>
		</div>






    <footer>
        <p>&copy; 2025 임종훈. All rights reserved.</p>
    </footer>

    <script>
        // 모달 스크립트 (탭 기능 추가)
        document.addEventListener('DOMContentLoaded', function () {
            const modal = document.getElementById('myModal');
            const modalContent = document.querySelector('.modal-content');
            const modalDynamicContent = document.getElementById('modal-dynamic-content');
            const closeButton = document.querySelector('.close-button');
            const taskButtons = document.querySelectorAll('.task-button');

            if (!modal || !modalContent || !closeButton || !taskButtons) { return; }

            taskButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const contentId = button.getAttribute('data-content-id');
                    const contentSource = document.getElementById(contentId);

                    if (contentSource) {
                        modalDynamicContent.innerHTML = contentSource.innerHTML;

                        const align = contentSource.getAttribute('data-align');
                        if (align === 'left') { modalContent.classList.add('text-left'); } 
                        else { modalContent.classList.remove('text-left'); }

                        modal.style.display = 'flex';

                        // ▼▼▼ 탭 기능 활성화 함수 호출 ▼▼▼
                        initializeModalTabs();
                    }
                });
            });

            // ▼▼▼ 모달 내부의 탭 기능을 초기화하는 함수 ▼▼▼
            function initializeModalTabs() {
                const tabs = modal.querySelectorAll('.modal-tabs li');
                const tabContents = modal.querySelectorAll('.modal-tab-content');
		const scrollContainer = modal.querySelector('.modal-tab-container');

                if (tabs.length === 0) return; // 탭이 없으면 실행 안함

                tabs.forEach(tab => {
                    tab.addEventListener('click', () => {
                        // 모든 탭과 콘텐츠에서 active 클래스 제거
                        tabs.forEach(t => t.classList.remove('active'));
                        tabContents.forEach(c => c.classList.remove('active'));

			if (scrollContainer) 
			{ 
				scrollContainer.scrollTop = 0; 
			}

                        // 클릭된 탭과 연결된 콘텐츠에 active 클래스 추가
                        tab.classList.add('active');
                        const targetId = tab.getAttribute('data-target');
                        const targetContent = modal.querySelector('#' + targetId);
                        if (targetContent) {
                            targetContent.classList.add('active');
                        }
                    });
                });
            }

            const closeModal = () => { modal.style.display = 'none'; };
            closeButton.addEventListener('click', closeModal);
            window.addEventListener('click', (event) => { if (event.target == modal) { closeModal(); } });
            window.addEventListener('keydown', (event) => { if (event.key === 'Escape') { closeModal(); } });
        });

        // 사이드 메뉴 스크립트
        document.addEventListener('DOMContentLoaded', function() {
            const sections = document.querySelectorAll('.content-section');
            const navLinks = document.querySelectorAll('.side-nav a');
            if (sections.length === 0 || navLinks.length === 0) return;
            const observer = new IntersectionObserver(entries => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        navLinks.forEach(link => {
                            link.classList.remove('active');
                            if (link.getAttribute('href').substring(1) === entry.target.id) {
                                link.classList.add('active');
                            }
                        });
                    }
                });
            }, { rootMargin: '-50% 0px -50% 0px' });
            sections.forEach(section => { observer.observe(section); });
        });

        // 이미지 라이트박스 스크립트
        document.addEventListener('DOMContentLoaded', function() {
            const imageModal = document.getElementById('imageModal');
            const largeImage = document.getElementById('largeImage');
            const closeImageModalButton = document.querySelector('.close-image-modal');
            if (!imageModal || !largeImage || !closeImageModalButton) return;
            document.body.addEventListener('click', function(event) {
                if (event.target.classList.contains('clickable-image')) {
                    imageModal.style.display = 'flex';
                    largeImage.src = event.target.src;
                }
            });
            const closeImageModal = () => { imageModal.style.display = 'none'; };
            closeImageModalButton.addEventListener('click', closeImageModal);
            imageModal.addEventListener('click', (event) => { if (event.target === imageModal) { closeImageModal(); } });
            window.addEventListener('keydown', (event) => { if (event.key === 'Escape') { closeImageModal(); }});
        });
    </script>
</body>
</html>